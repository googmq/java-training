# 线程安全

**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都能够获得正确的结果，那么这个对象是线程安全的。**

## 不可变

在Java语言中（JDK1.5以后）。不可变对象（Immutable）对象一定是线程安全的。

如果共享数据是一个级别数据类型，只要定义时使用了final关键字修饰它就可以保证它是不变的；如果共享数据是一个对象，那么就要保证对象的所有方法都不会对其状态产生任何影响（对象的方法都不改变值，而是直接返回新生产的对象）。

~~~java
public class Integer {
    
    private final int value;
    
    public Integer(int value) {
        this.value = value;
    }
}
~~~

## 绝对线程安全

除了不可变的情况外，满足黑体线程安全定义的类可以认为是“**绝对线程安全**”。要实现绝对线程安全需要付出非常大的代价。在Java API中标注为线程安全的类，大多数都不能满足绝对线程安全的要求。

用线程安全的Vector举个例子：

~~~java
private static Vector(Integer) vector = new Vector();

public static void main(String[] args) {
    while(true) {
        for (int i = 0; i < 10; i++) {
            vector.add(i);
        }
        
        new Thread(new Runnable () {
            @Override
            public void run() {
                for (int i = 0; i < vector.size(); i++) {
                    vector.remove(i);
                }
            }
        }).start();
        
        new Thread(new Runnable () {
            @Override
            public void run() {
                for (int i = 0; i < vector.size(); i++) {
                    vector.get(i);
                }
            }
        }).start();
        
        while(Thread.activeCount() > 20);
    }
}

//请分析一下这里会出现什么异常？为什么会出现这个异常？怎么搞定这个异常？
~~~

## 相对线程安全

**这个是我们通常意义上讲的线程安全。**它可以保证这个对象单独的线程操作是安全的，在调用时不需要额外的保障措施，但是对于某些特定顺序的连续调用，可能需要额外的同步手段来保证调用的正确性。

## 线程兼容

指对象本身不是线程安全的，但是可以通过调用正确的同步手段来保证对象在并发环境中可以安全的使用。

## 线程对立

指无论是否采用了同步手段，都无法保证正确的在并发环境中使用此对象。Thread类的suspend()方法和resume()方法就是典型的线程对立的例子。

# 线程安全的实现方法

## 互斥同步（悲观锁）

互斥同步（Mutual Exclusion & Synchronization）是常见的一种并发正确保障手段。**同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或一些，使用信号量或读锁的时候）线程使用。

最基本的互斥手段是synchronized关键字，经过编译以后，会在同步块的前后分别形成monitorenter和monitorexit字节码指令。这两个指令都需要一个reference类型的参数来指明要锁定的对象：如果指定了对象，那就是这个对象的reference；如果没有指定且修饰的是实例方法，那么就是实例自身的reference；如果没有指定且修饰的是类方法，那么就是Class对象的reference。

除了synchronized关键字以外，还可以使用java.util.concurrent包中重入锁(ReentrantLock)来实现同步。相比synchronized，ReentrantLock增加了一些高级特性：

- 等待可中断：指当持有锁的线程长期不释放锁的死后，正在等待的线程可以选择放弃等待
- 公平锁：指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；非公平锁不保证这一点。synchronized和ReentrantLock的默认情况下都是非公平的，但是ReentrantLock可以通过构造参数使用公平锁
- 锁绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中只能实现一个隐含的条件，要使用多个条件时只能使用多个synchronized

**在jdk1.5之前ReentrantLock比synchronized有性能优势，在jdk1.5以后，两种性能不相上下。**

## 非互斥同步（乐观锁）

互斥同步最大的问题就是线程阻塞和唤醒带来的性能问题，也称为阻塞同步（悲观锁）。

另外一种同步方式是基于冲突检测的策略：先进行操作，如果没有竞争，那么操作就成功了；如果出现了竞争，产生了冲突，那就采取补救措施。这种方式也被称为非阻塞同步（乐观锁）。

## 不同步

要保证线程安全，并不是一定要进行同步。当操作本身不涉及共享数据时，也可以不使用同步措施来保证正确性。

### 可重入代码（Reentrant Code）

也叫做纯代码，可以在代码执行的任意时候中断它，去执行其他的代码，而在控制权返回后，原来的程序不会出现任何错误。需要满足以下条件：

1. 不依赖堆上的数据和公用的系统资源
2. 用到的状态都是由参数传入
3. 不调用非可重复的方法

**可重复方法只要输入了同样的参数，不管在什么条件下执行，不管执行多少次，都一定会返回相同的结果。**

### 线程本地存储（Thread Local Storage）

将共享数据在执行线程中保存一份副本，将副本的可见性限制在线程内，这样，无需同步也可以保证线程之间不会出现共享数据的竞争。

# 锁优化

## 自旋锁于自适应自旋

在互斥同步中，线程的阻塞和回复都需要从用户态切换到内核态，对性能有一定的影响。在多个线程竞争共享数据时，可以让另外一个处理起核上的等待线程不阻塞，而是“等待”一段时间来等待锁的释放。为了让线程等待，只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自适应自旋表示自旋的次数不是固定的，而是虚拟机通过监控程序运行和性能状态，自己调整每个锁上面自旋的次数。

## 锁消除

在虚拟机即时编译器运行时，对于一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

出现锁消除的原因是Java代码中有许多同步措施并不是编写代码的程序员加入的，而是被调用的api自带的。

~~~java
public String concatStr(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}

// append方法是一个同步方法，有锁。但是由于sb对象封闭在方法内，只在栈上而不是堆上，属于线程封闭，不会出现线程间的共享数据竞争。所以可以进行锁消除。
~~~

## 锁粗化

在编写代码时，程序员会把同步块的作用范围限制得尽可能地小，但是如果一系列操作都在对一个对象反复加锁和解锁或在循环中加锁，会导致没有线程竞争的情况下不必要的加锁/解锁产生性能问题。此时虚拟机会直接把加锁的范围扩大到整个操作的外围，加一次锁就可以了。

## 轻量级锁

使用对象的mark word和竞争线程的当前栈帧，标记获得对象锁的线程，在没有发生线程竞争时，可以通过CAS消除无竞争时的同步操作使用的互斥量。

## 偏向锁

使用对象的mark word和竞争线程的当前栈帧，标记获得对象锁的线程，在没有发生线程竞争时，直接消除同步操作。

